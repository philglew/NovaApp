{"ast":null,"code":"/*! @azure/msal-common v14.16.0 2024-11-05 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.mjs';\nimport { Separators, GrantType, AuthenticationScheme, PromptValue, HeaderNames } from '../utils/Constants.mjs';\nimport { CLIENT_ID, RETURN_SPA_CODE } from '../constants/AADServerParamKeys.mjs';\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { nowSeconds } from '../utils/TimeUtils.mjs';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { RequestValidator } from '../request/RequestValidator.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { getClientAssertion } from '../utils/ClientAssertionUtils.mjs';\nimport { requestCannotBeMade, authorizationCodeMissingFromServerResponse } from '../error/ClientAuthErrorCodes.mjs';\nimport { logoutRequestEmpty, missingSshJwk } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Oauth2.0 Authorization Code client\r\n * @internal\r\n */\nclass AuthorizationCodeClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    var _this$config$authOpti;\n    super(configuration, performanceClient);\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    this.includeRedirectUri = true;\n    this.oidcDefaultScopes = (_this$config$authOpti = this.config.authOptions.authority.options.OIDCOptions) === null || _this$config$authOpti === void 0 ? void 0 : _this$config$authOpti.defaultScopes;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n  async getAuthCodeUrl(request) {\n    var _this$performanceClie;\n    (_this$performanceClie = this.performanceClient) === null || _this$performanceClie === void 0 || _this$performanceClie.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n    const queryString = await invokeAsync(this.createAuthCodeUrlQueryString.bind(this), PerformanceEvents.AuthClientCreateQueryString, this.logger, this.performanceClient, request.correlationId)(request);\n    return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\n  }\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n  async acquireToken(request, authCodePayload) {\n    var _this$performanceClie2, _response$headers;\n    (_this$performanceClie2 = this.performanceClient) === null || _this$performanceClie2 === void 0 || _this$performanceClie2.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n    if (!request.code) {\n      throw createClientAuthError(requestCannotBeMade);\n    }\n    const reqTimestamp = nowSeconds();\n    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);\n    // Retrieve requestId from response headers\n    const requestId = (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers[HeaderNames.X_MS_REQUEST_ID];\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);\n    // Validate response. This function throws a server error if an error is returned by the server.\n    responseHandler.validateTokenResponse(response.body);\n    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);\n  }\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n  handleFragmentResponse(serverParams, cachedState) {\n    // Handle responses.\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n    // Get code response\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState);\n    // throw when there is no auth code in the response\n    if (!serverParams.code) {\n      throw createClientAuthError(authorizationCodeMissingFromServerResponse);\n    }\n    return serverParams;\n  }\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n  getLogoutUri(logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw createClientConfigurationError(logoutRequestEmpty);\n    }\n    const queryString = this.createLogoutUrlQueryString(logoutRequest);\n    // Construct logout URI\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  }\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n  async executeTokenRequest(authority, request) {\n    var _this$performanceClie3, _request$tokenBodyPar;\n    (_this$performanceClie3 = this.performanceClient) === null || _this$performanceClie3 === void 0 || _this$performanceClie3.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n    const queryParametersString = this.createTokenQueryParameters(request);\n    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\n    let ccsCredential = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCredential = {\n          credential: \"\".concat(clientInfo.uid).concat(Separators.CLIENT_INFO_SEPARATOR).concat(clientInfo.utid),\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    }\n    const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n    const thumbprint = {\n      clientId: ((_request$tokenBodyPar = request.tokenBodyParameters) === null || _request$tokenBodyPar === void 0 ? void 0 : _request$tokenBodyPar.clientId) || this.config.authOptions.clientId,\n      authority: authority.canonicalAuthority,\n      scopes: request.scopes,\n      claims: request.claims,\n      authenticationScheme: request.authenticationScheme,\n      resourceRequestMethod: request.resourceRequestMethod,\n      resourceRequestUri: request.resourceRequestUri,\n      shrClaims: request.shrClaims,\n      sshKid: request.sshKid\n    };\n    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);\n  }\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n  async createTokenRequestBody(request) {\n    var _this$performanceClie4, _request$tokenBodyPar2;\n    (_this$performanceClie4 = this.performanceClient) === null || _this$performanceClie4 === void 0 || _this$performanceClie4.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n    const parameterBuilder = new RequestParameterBuilder(request.correlationId, this.performanceClient);\n    parameterBuilder.addClientId(request.embeddedClientId || ((_request$tokenBodyPar2 = request.tokenBodyParameters) === null || _request$tokenBodyPar2 === void 0 ? void 0 : _request$tokenBodyPar2[CLIENT_ID]) || this.config.authOptions.clientId);\n    /*\r\n     * For hybrid spa flow, there will be a code but no verifier\r\n     * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n     */\n    if (!this.includeRedirectUri) {\n      // Just validate\n      RequestValidator.validateRedirectUri(request.redirectUri);\n    } else {\n      // Validate and include redirect uri\n      parameterBuilder.addRedirectUri(request.redirectUri);\n    }\n    // Add scope array, parameter builder will add default scopes and dedupe\n    parameterBuilder.addScopes(request.scopes, true, this.oidcDefaultScopes);\n    // add code: user set, not validated\n    parameterBuilder.addAuthorizationCode(request.code);\n    // Add library metadata\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    parameterBuilder.addThrottling();\n    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n    }\n    // add code_verifier if passed\n    if (request.codeVerifier) {\n      parameterBuilder.addCodeVerifier(request.codeVerifier);\n    }\n    if (this.config.clientCredentials.clientSecret) {\n      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      const clientAssertion = this.config.clientCredentials.clientAssertion;\n      parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\n      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n    }\n    parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n    parameterBuilder.addClientInfo();\n    if (request.authenticationScheme === AuthenticationScheme.POP) {\n      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n      let reqCnfData;\n      if (!request.popKid) {\n        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n        reqCnfData = generatedReqCnfData.reqCnfString;\n      } else {\n        reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n      }\n      // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n      parameterBuilder.addPopToken(reqCnfData);\n    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n      if (request.sshJwk) {\n        parameterBuilder.addSshJwk(request.sshJwk);\n      } else {\n        throw createClientConfigurationError(missingSshJwk);\n      }\n    }\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    let ccsCred = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCred = {\n          credential: \"\".concat(clientInfo.uid).concat(Separators.CLIENT_INFO_SEPARATOR).concat(clientInfo.utid),\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    } else {\n      ccsCred = request.ccsCredential;\n    }\n    // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n    if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n      switch (ccsCred.type) {\n        case CcsCredentialType.HOME_ACCOUNT_ID:\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n          break;\n        case CcsCredentialType.UPN:\n          parameterBuilder.addCcsUpn(ccsCred.credential);\n          break;\n      }\n    }\n    if (request.embeddedClientId) {\n      parameterBuilder.addBrokerParameters({\n        brokerClientId: this.config.authOptions.clientId,\n        brokerRedirectUri: this.config.authOptions.redirectUri\n      });\n    }\n    if (request.tokenBodyParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n    }\n    // Add hybrid spa parameters if not already provided\n    if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {\n      parameterBuilder.addExtraQueryParameters({\n        [RETURN_SPA_CODE]: \"1\"\n      });\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n  async createAuthCodeUrlQueryString(request) {\n    var _this$performanceClie5, _request$extraQueryPa;\n    // generate the correlationId if not set by the user and add\n    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    (_this$performanceClie5 = this.performanceClient) === null || _this$performanceClie5 === void 0 || _this$performanceClie5.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, correlationId);\n    const parameterBuilder = new RequestParameterBuilder(correlationId, this.performanceClient);\n    parameterBuilder.addClientId(request.embeddedClientId || ((_request$extraQueryPa = request.extraQueryParameters) === null || _request$extraQueryPa === void 0 ? void 0 : _request$extraQueryPa[CLIENT_ID]) || this.config.authOptions.clientId);\n    const requestScopes = [...(request.scopes || []), ...(request.extraScopesToConsent || [])];\n    parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);\n    // validate the redirectUri (to be a non null value)\n    parameterBuilder.addRedirectUri(request.redirectUri);\n    parameterBuilder.addCorrelationId(correlationId);\n    // add response_mode. If not passed in it defaults to query.\n    parameterBuilder.addResponseMode(request.responseMode);\n    // add response_type = code\n    parameterBuilder.addResponseTypeCode();\n    // add library info parameters\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    if (!isOidcProtocolMode(this.config)) {\n      parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    }\n    // add client_info=1\n    parameterBuilder.addClientInfo();\n    if (request.codeChallenge && request.codeChallengeMethod) {\n      parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n    }\n    if (request.prompt) {\n      parameterBuilder.addPrompt(request.prompt);\n    }\n    if (request.domainHint) {\n      parameterBuilder.addDomainHint(request.domainHint);\n    }\n    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n      // AAD will throw if prompt=select_account is passed with an account hint\n      if (request.sid && request.prompt === PromptValue.NONE) {\n        // SessionID is only used in silent calls\n        this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n        parameterBuilder.addSid(request.sid);\n      } else if (request.account) {\n        const accountSid = this.extractAccountSid(request.account);\n        let accountLoginHintClaim = this.extractLoginHint(request.account);\n        if (accountLoginHintClaim && request.domainHint) {\n          this.logger.warning(\"AuthorizationCodeClient.createAuthCodeUrlQueryString: \\\"domainHint\\\" param is set, skipping opaque \\\"login_hint\\\" claim. Please consider not passing domainHint\");\n          accountLoginHintClaim = null;\n        }\n        // If login_hint claim is present, use it over sid/username\n        if (accountLoginHintClaim) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n          parameterBuilder.addLoginHint(accountLoginHintClaim);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        } else if (accountSid && request.prompt === PromptValue.NONE) {\n          /*\r\n           * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n           * SessionId is only used in silent calls\r\n           */\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n          parameterBuilder.addSid(accountSid);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        } else if (request.loginHint) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n          parameterBuilder.addLoginHint(request.loginHint);\n          parameterBuilder.addCcsUpn(request.loginHint);\n        } else if (request.account.username) {\n          // Fallback to account username if provided\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n          parameterBuilder.addLoginHint(request.account.username);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        }\n      } else if (request.loginHint) {\n        this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n        parameterBuilder.addLoginHint(request.loginHint);\n        parameterBuilder.addCcsUpn(request.loginHint);\n      }\n    } else {\n      this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n    }\n    if (request.nonce) {\n      parameterBuilder.addNonce(request.nonce);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    if (request.embeddedClientId) {\n      parameterBuilder.addBrokerParameters({\n        brokerClientId: this.config.authOptions.clientId,\n        brokerRedirectUri: this.config.authOptions.redirectUri\n      });\n    }\n    this.addExtraQueryParams(request, parameterBuilder);\n    if (request.nativeBroker) {\n      // signal ests that this is a WAM call\n      parameterBuilder.addNativeBroker();\n      // pass the req_cnf for POP\n      if (request.authenticationScheme === AuthenticationScheme.POP) {\n        const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n        // req_cnf is always sent as a string for SPAs\n        let reqCnfData;\n        if (!request.popKid) {\n          const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n          reqCnfData = generatedReqCnfData.reqCnfString;\n        } else {\n          reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n        }\n        parameterBuilder.addPopToken(reqCnfData);\n      }\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n  createLogoutUrlQueryString(request) {\n    const parameterBuilder = new RequestParameterBuilder(request.correlationId, this.performanceClient);\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n    this.addExtraQueryParams(request, parameterBuilder);\n    return parameterBuilder.createQueryString();\n  }\n  addExtraQueryParams(request, parameterBuilder) {\n    const hasRequestInstanceAware = request.extraQueryParameters && request.extraQueryParameters.hasOwnProperty(\"instance_aware\");\n    // Set instance_aware flag if config auth param is set\n    if (!hasRequestInstanceAware && this.config.authOptions.instanceAware) {\n      request.extraQueryParameters = request.extraQueryParameters || {};\n      request.extraQueryParameters[\"instance_aware\"] = \"true\";\n    }\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n  }\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n  extractAccountSid(account) {\n    var _account$idTokenClaim;\n    return ((_account$idTokenClaim = account.idTokenClaims) === null || _account$idTokenClaim === void 0 ? void 0 : _account$idTokenClaim.sid) || null;\n  }\n  extractLoginHint(account) {\n    var _account$idTokenClaim2;\n    return ((_account$idTokenClaim2 = account.idTokenClaims) === null || _account$idTokenClaim2 === void 0 ? void 0 : _account$idTokenClaim2.login_hint) || null;\n  }\n}\nexport { AuthorizationCodeClient };","map":{"version":3,"names":["AuthorizationCodeClient","BaseClient","constructor","configuration","performanceClient","_this$config$authOpti","includeRedirectUri","oidcDefaultScopes","config","authOptions","authority","options","OIDCOptions","defaultScopes","getAuthCodeUrl","request","_this$performanceClie","addQueueMeasurement","PerformanceEvents","GetAuthCodeUrl","correlationId","queryString","invokeAsync","createAuthCodeUrlQueryString","bind","AuthClientCreateQueryString","logger","UrlString","appendQueryString","authorizationEndpoint","acquireToken","authCodePayload","_this$performanceClie2","_response$headers","AuthClientAcquireToken","code","createClientAuthError","requestCannotBeMade","reqTimestamp","nowSeconds","response","executeTokenRequest","AuthClientExecuteTokenRequest","requestId","headers","HeaderNames","X_MS_REQUEST_ID","responseHandler","ResponseHandler","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","HandleServerTokenResponse","undefined","handleFragmentResponse","serverParams","cachedState","validateServerAuthorizationCodeResponse","authorizationCodeMissingFromServerResponse","getLogoutUri","logoutRequest","createClientConfigurationError","logoutRequestEmpty","createLogoutUrlQueryString","endSessionEndpoint","_this$performanceClie3","_request$tokenBodyPar","queryParametersString","createTokenQueryParameters","endpoint","tokenEndpoint","requestBody","createTokenRequestBody","AuthClientCreateTokenRequestBody","ccsCredential","clientInfo","buildClientInfo","base64Decode","credential","concat","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","verbose","createTokenRequestHeaders","thumbprint","tokenBodyParameters","canonicalAuthority","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","executePostToTokenEndpoint","AuthorizationCodeClientExecutePostToTokenEndpoint","_this$performanceClie4","_request$tokenBodyPar2","parameterBuilder","RequestParameterBuilder","addClientId","embeddedClientId","CLIENT_ID","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","isOidcProtocolMode","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","getClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","reqCnfData","popKid","generatedReqCnfData","generateCnf","PopTokenGenerateCnf","reqCnfString","encodeKid","addPopToken","SSH","sshJwk","addSshJwk","missingSshJwk","StringUtils","isEmptyObj","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","addBrokerParameters","brokerClientId","brokerRedirectUri","addExtraQueryParameters","enableSpaAuthorizationCode","RETURN_SPA_CODE","createQueryString","_this$performanceClie5","_request$extraQueryPa","cryptoInterface","createNewGuid","extraQueryParameters","requestScopes","extraScopesToConsent","addCorrelationId","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","account","accountSid","extractAccountSid","accountLoginHintClaim","extractLoginHint","warning","addLoginHint","homeAccountId","loginHint","username","nonce","addNonce","state","addState","addExtraQueryParams","nativeBroker","addNativeBroker","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","logoutHint","addLogoutHint","hasRequestInstanceAware","hasOwnProperty","instanceAware","_account$idTokenClaim","idTokenClaims","_account$idTokenClaim2","login_hint"],"sources":["C:\\temp\\NovaApp\\src\\nova.web\\node_modules\\@azure\\msal-common\\src\\client\\AuthorizationCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient.js\";\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest.js\";\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest.js\";\nimport { Authority } from \"../authority/Authority.js\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder.js\";\nimport {\n    GrantType,\n    AuthenticationScheme,\n    PromptValue,\n    Separators,\n    HeaderNames,\n} from \"../utils/Constants.js\";\nimport * as AADServerParamKeys from \"../constants/AADServerParamKeys.js\";\nimport {\n    ClientConfiguration,\n    isOidcProtocolMode,\n} from \"../config/ClientConfiguration.js\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse.js\";\nimport { NetworkResponse } from \"../network/NetworkResponse.js\";\nimport { ResponseHandler } from \"../response/ResponseHandler.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { StringUtils } from \"../utils/StringUtils.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport { UrlString } from \"../url/UrlString.js\";\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse.js\";\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest.js\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator.js\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint.js\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload.js\";\nimport * as TimeUtils from \"../utils/TimeUtils.js\";\nimport { AccountInfo } from \"../account/AccountInfo.js\";\nimport {\n    buildClientInfoFromHomeAccountId,\n    buildClientInfo,\n} from \"../account/ClientInfo.js\";\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential.js\";\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError.js\";\nimport { RequestValidator } from \"../request/RequestValidator.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { ClientAssertion } from \"../account/ClientCredentials.js\";\nimport { getClientAssertion } from \"../utils/ClientAssertionUtils.js\";\n\n/**\n * Oauth2.0 Authorization Code client\n * @internal\n */\nexport class AuthorizationCodeClient extends BaseClient {\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    protected includeRedirectUri: boolean = true;\n    private oidcDefaultScopes;\n\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n        this.oidcDefaultScopes =\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n    }\n\n    /**\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\n     * application. The URL target the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * acquireToken(AuthorizationCodeRequest)\n     * @param request\n     */\n    async getAuthCodeUrl(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.GetAuthCodeUrl,\n            request.correlationId\n        );\n\n        const queryString = await invokeAsync(\n            this.createAuthCodeUrlQueryString.bind(this),\n            PerformanceEvents.AuthClientCreateQueryString,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        return UrlString.appendQueryString(\n            this.authority.authorizationEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n     * authorization_code_grant\n     * @param request\n     */\n    async acquireToken(\n        request: CommonAuthorizationCodeRequest,\n        authCodePayload?: AuthorizationCodePayload\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientAcquireToken,\n            request.correlationId\n        );\n\n        if (!request.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.requestCannotBeMade\n            );\n        }\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await invokeAsync(\n            this.executeTokenRequest.bind(this),\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authority, request);\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin,\n            this.performanceClient\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n\n        return invokeAsync(\n            responseHandler.handleServerTokenResponse.bind(responseHandler),\n            PerformanceEvents.HandleServerTokenResponse,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            authCodePayload,\n            undefined,\n            undefined,\n            undefined,\n            requestId\n        );\n    }\n\n    /**\n     * Handles the hash fragment response from public client code request. Returns a code response used by\n     * the client to exchange for a token in acquireToken.\n     * @param hashFragment\n     */\n    handleFragmentResponse(\n        serverParams: ServerAuthorizationCodeResponse,\n        cachedState: string\n    ): AuthorizationCodePayload {\n        // Handle responses.\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            null,\n            null\n        );\n\n        // Get code response\n        responseHandler.validateServerAuthorizationCodeResponse(\n            serverParams,\n            cachedState\n        );\n\n        // throw when there is no auth code in the response\n        if (!serverParams.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.authorizationCodeMissingFromServerResponse\n            );\n        }\n\n        return serverParams as AuthorizationCodePayload;\n    }\n\n    /**\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param authorityUri\n     */\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\n        // Throw error if logoutRequest is null/undefined\n        if (!logoutRequest) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.logoutRequestEmpty\n            );\n        }\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\n\n        // Construct logout URI\n        return UrlString.appendQueryString(\n            this.authority.endSessionEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority\n     * @param request\n     */\n    private async executeTokenRequest(\n        authority: Authority,\n        request: CommonAuthorizationCodeRequest\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            request.correlationId\n        );\n\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n\n        const requestBody = await invokeAsync(\n            this.createTokenRequestBody.bind(this),\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        let ccsCredential: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCredential = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        }\n        const headers: Record<string, string> = this.createTokenRequestHeaders(\n            ccsCredential || request.ccsCredential\n        );\n\n        const thumbprint: RequestThumbprint = {\n            clientId:\n                request.tokenBodyParameters?.clientId ||\n                this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        return invokeAsync(\n            this.executePostToTokenEndpoint.bind(this),\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId,\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint\n        );\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request\n     */\n    private async createTokenRequestBody(\n        request: CommonAuthorizationCodeRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const parameterBuilder = new RequestParameterBuilder(\n            request.correlationId,\n            this.performanceClient\n        );\n\n        parameterBuilder.addClientId(\n            request.embeddedClientId ||\n                request.tokenBodyParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        /*\n         * For hybrid spa flow, there will be a code but no verifier\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n         */\n        if (!this.includeRedirectUri) {\n            // Just validate\n            RequestValidator.validateRedirectUri(request.redirectUri);\n        } else {\n            // Validate and include redirect uri\n            parameterBuilder.addRedirectUri(request.redirectUri);\n        }\n\n        // Add scope array, parameter builder will add default scopes and dedupe\n        parameterBuilder.addScopes(\n            request.scopes,\n            true,\n            this.oidcDefaultScopes\n        );\n\n        // add code: user set, not validated\n        parameterBuilder.addAuthorizationCode(request.code);\n\n        // Add library metadata\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        parameterBuilder.addApplicationTelemetry(\n            this.config.telemetry.application\n        );\n        parameterBuilder.addThrottling();\n\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        // add code_verifier if passed\n        if (request.codeVerifier) {\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\n        }\n\n        if (this.config.clientCredentials.clientSecret) {\n            parameterBuilder.addClientSecret(\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion: ClientAssertion =\n                this.config.clientCredentials.clientAssertion;\n\n            parameterBuilder.addClientAssertion(\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            parameterBuilder.addClientAssertionType(\n                clientAssertion.assertionType\n            );\n        }\n\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n        parameterBuilder.addClientInfo();\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(\n                this.cryptoUtils,\n                this.performanceClient\n            );\n\n            let reqCnfData;\n            if (!request.popKid) {\n                const generatedReqCnfData = await invokeAsync(\n                    popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                    PerformanceEvents.PopTokenGenerateCnf,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(request, this.logger);\n                reqCnfData = generatedReqCnfData.reqCnfString;\n            } else {\n                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n            }\n\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            parameterBuilder.addPopToken(reqCnfData);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n            } else {\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.missingSshJwk\n                );\n            }\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        let ccsCred: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCred = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        } else {\n            ccsCred = request.ccsCredential;\n        }\n\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n            switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            ccsCred.credential\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"Could not parse home account ID for CCS Header: \" +\n                                e\n                        );\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\n                    break;\n            }\n        }\n\n        if (request.embeddedClientId) {\n            parameterBuilder.addBrokerParameters({\n                brokerClientId: this.config.authOptions.clientId,\n                brokerRedirectUri: this.config.authOptions.redirectUri,\n            });\n        }\n\n        if (request.tokenBodyParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.tokenBodyParameters\n            );\n        }\n\n        // Add hybrid spa parameters if not already provided\n        if (\n            request.enableSpaAuthorizationCode &&\n            (!request.tokenBodyParameters ||\n                !request.tokenBodyParameters[\n                    AADServerParamKeys.RETURN_SPA_CODE\n                ])\n        ) {\n            parameterBuilder.addExtraQueryParameters({\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\",\n            });\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n     * @param request\n     */\n    private async createAuthCodeUrlQueryString(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<string> {\n        // generate the correlationId if not set by the user and add\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateQueryString,\n            correlationId\n        );\n\n        const parameterBuilder = new RequestParameterBuilder(\n            correlationId,\n            this.performanceClient\n        );\n\n        parameterBuilder.addClientId(\n            request.embeddedClientId ||\n                request.extraQueryParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        const requestScopes = [\n            ...(request.scopes || []),\n            ...(request.extraScopesToConsent || []),\n        ];\n        parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);\n\n        // validate the redirectUri (to be a non null value)\n        parameterBuilder.addRedirectUri(request.redirectUri);\n\n        parameterBuilder.addCorrelationId(correlationId);\n\n        // add response_mode. If not passed in it defaults to query.\n        parameterBuilder.addResponseMode(request.responseMode);\n\n        // add response_type = code\n        parameterBuilder.addResponseTypeCode();\n\n        // add library info parameters\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        if (!isOidcProtocolMode(this.config)) {\n            parameterBuilder.addApplicationTelemetry(\n                this.config.telemetry.application\n            );\n        }\n\n        // add client_info=1\n        parameterBuilder.addClientInfo();\n\n        if (request.codeChallenge && request.codeChallengeMethod) {\n            parameterBuilder.addCodeChallengeParams(\n                request.codeChallenge,\n                request.codeChallengeMethod\n            );\n        }\n\n        if (request.prompt) {\n            parameterBuilder.addPrompt(request.prompt);\n        }\n\n        if (request.domainHint) {\n            parameterBuilder.addDomainHint(request.domainHint);\n        }\n\n        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n            // AAD will throw if prompt=select_account is passed with an account hint\n            if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\n                    \"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\"\n                );\n                parameterBuilder.addSid(request.sid);\n            } else if (request.account) {\n                const accountSid = this.extractAccountSid(request.account);\n                let accountLoginHintClaim = this.extractLoginHint(\n                    request.account\n                );\n\n                if (accountLoginHintClaim && request.domainHint) {\n                    this.logger.warning(\n                        `AuthorizationCodeClient.createAuthCodeUrlQueryString: \"domainHint\" param is set, skipping opaque \"login_hint\" claim. Please consider not passing domainHint`\n                    );\n                    accountLoginHintClaim = null;\n                }\n\n                // If login_hint claim is present, use it over sid/username\n                if (accountLoginHintClaim) {\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: login_hint claim present on account\"\n                    );\n                    parameterBuilder.addLoginHint(accountLoginHintClaim);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                    /*\n                     * If account and loginHint are provided, we will check account first for sid before adding loginHint\n                     * SessionId is only used in silent calls\n                     */\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\"\n                    );\n                    parameterBuilder.addSid(accountSid);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                } else if (request.loginHint) {\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Adding login_hint from request\"\n                    );\n                    parameterBuilder.addLoginHint(request.loginHint);\n                    parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                    // Fallback to account username if provided\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Adding login_hint from account\"\n                    );\n                    parameterBuilder.addLoginHint(request.account.username);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                }\n            } else if (request.loginHint) {\n                this.logger.verbose(\n                    \"createAuthCodeUrlQueryString: No account, adding login_hint from request\"\n                );\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n            }\n        } else {\n            this.logger.verbose(\n                \"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\"\n            );\n        }\n\n        if (request.nonce) {\n            parameterBuilder.addNonce(request.nonce);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (\n            request.claims ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        if (request.embeddedClientId) {\n            parameterBuilder.addBrokerParameters({\n                brokerClientId: this.config.authOptions.clientId,\n                brokerRedirectUri: this.config.authOptions.redirectUri,\n            });\n        }\n\n        this.addExtraQueryParams(request, parameterBuilder);\n\n        if (request.nativeBroker) {\n            // signal ests that this is a WAM call\n            parameterBuilder.addNativeBroker();\n\n            // pass the req_cnf for POP\n            if (request.authenticationScheme === AuthenticationScheme.POP) {\n                const popTokenGenerator = new PopTokenGenerator(\n                    this.cryptoUtils\n                );\n\n                // req_cnf is always sent as a string for SPAs\n                let reqCnfData;\n                if (!request.popKid) {\n                    const generatedReqCnfData = await invokeAsync(\n                        popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                        PerformanceEvents.PopTokenGenerateCnf,\n                        this.logger,\n                        this.performanceClient,\n                        request.correlationId\n                    )(request, this.logger);\n                    reqCnfData = generatedReqCnfData.reqCnfString;\n                } else {\n                    reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n                }\n                parameterBuilder.addPopToken(reqCnfData);\n            }\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `EndSessionRequest` and creates a URL\n     * @param request\n     */\n    private createLogoutUrlQueryString(\n        request: CommonEndSessionRequest\n    ): string {\n        const parameterBuilder = new RequestParameterBuilder(\n            request.correlationId,\n            this.performanceClient\n        );\n\n        if (request.postLogoutRedirectUri) {\n            parameterBuilder.addPostLogoutRedirectUri(\n                request.postLogoutRedirectUri\n            );\n        }\n\n        if (request.correlationId) {\n            parameterBuilder.addCorrelationId(request.correlationId);\n        }\n\n        if (request.idTokenHint) {\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (request.logoutHint) {\n            parameterBuilder.addLogoutHint(request.logoutHint);\n        }\n\n        this.addExtraQueryParams(request, parameterBuilder);\n\n        return parameterBuilder.createQueryString();\n    }\n\n    private addExtraQueryParams(\n        request: CommonAuthorizationUrlRequest | CommonEndSessionRequest,\n        parameterBuilder: RequestParameterBuilder\n    ) {\n        const hasRequestInstanceAware =\n            request.extraQueryParameters &&\n            request.extraQueryParameters.hasOwnProperty(\"instance_aware\");\n\n        // Set instance_aware flag if config auth param is set\n        if (!hasRequestInstanceAware && this.config.authOptions.instanceAware) {\n            request.extraQueryParameters = request.extraQueryParameters || {};\n            request.extraQueryParameters[\"instance_aware\"] = \"true\";\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.extraQueryParameters\n            );\n        }\n    }\n\n    /**\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n     * @param account\n     */\n    private extractAccountSid(account: AccountInfo): string | null {\n        return account.idTokenClaims?.sid || null;\n    }\n\n    private extractLoginHint(account: AccountInfo): string | null {\n        return account.idTokenClaims?.login_hint || null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}