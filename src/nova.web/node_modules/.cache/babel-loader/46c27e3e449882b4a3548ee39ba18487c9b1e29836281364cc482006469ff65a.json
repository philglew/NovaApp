{"ast":null,"code":"/*! @azure/msal-common v14.16.0 2024-11-05 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.mjs';\nimport { Separators, GrantType, AuthenticationScheme, PromptValue, HeaderNames } from '../utils/Constants.mjs';\nimport { CLIENT_ID, RETURN_SPA_CODE } from '../constants/AADServerParamKeys.mjs';\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { nowSeconds } from '../utils/TimeUtils.mjs';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { RequestValidator } from '../request/RequestValidator.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { getClientAssertion } from '../utils/ClientAssertionUtils.mjs';\nimport { requestCannotBeMade, authorizationCodeMissingFromServerResponse } from '../error/ClientAuthErrorCodes.mjs';\nimport { logoutRequestEmpty, missingSshJwk } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Oauth2.0 Authorization Code client\r\n * @internal\r\n */\nclass AuthorizationCodeClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    this.includeRedirectUri = true;\n    this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n  async getAuthCodeUrl(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n    const queryString = await invokeAsync(this.createAuthCodeUrlQueryString.bind(this), PerformanceEvents.AuthClientCreateQueryString, this.logger, this.performanceClient, request.correlationId)(request);\n    return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\n  }\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n  async acquireToken(request, authCodePayload) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n    if (!request.code) {\n      throw createClientAuthError(requestCannotBeMade);\n    }\n    const reqTimestamp = nowSeconds();\n    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);\n    // Retrieve requestId from response headers\n    const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);\n    // Validate response. This function throws a server error if an error is returned by the server.\n    responseHandler.validateTokenResponse(response.body);\n    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);\n  }\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n  handleFragmentResponse(serverParams, cachedState) {\n    // Handle responses.\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n    // Get code response\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState);\n    // throw when there is no auth code in the response\n    if (!serverParams.code) {\n      throw createClientAuthError(authorizationCodeMissingFromServerResponse);\n    }\n    return serverParams;\n  }\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n  getLogoutUri(logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw createClientConfigurationError(logoutRequestEmpty);\n    }\n    const queryString = this.createLogoutUrlQueryString(logoutRequest);\n    // Construct logout URI\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  }\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n  async executeTokenRequest(authority, request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n    const queryParametersString = this.createTokenQueryParameters(request);\n    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\n    let ccsCredential = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCredential = {\n          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    }\n    const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n    const thumbprint = {\n      clientId: request.tokenBodyParameters?.clientId || this.config.authOptions.clientId,\n      authority: authority.canonicalAuthority,\n      scopes: request.scopes,\n      claims: request.claims,\n      authenticationScheme: request.authenticationScheme,\n      resourceRequestMethod: request.resourceRequestMethod,\n      resourceRequestUri: request.resourceRequestUri,\n      shrClaims: request.shrClaims,\n      sshKid: request.sshKid\n    };\n    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);\n  }\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n  async createTokenRequestBody(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n    const parameterBuilder = new RequestParameterBuilder(request.correlationId, this.performanceClient);\n    parameterBuilder.addClientId(request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);\n    /*\r\n     * For hybrid spa flow, there will be a code but no verifier\r\n     * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n     */\n    if (!this.includeRedirectUri) {\n      // Just validate\n      RequestValidator.validateRedirectUri(request.redirectUri);\n    } else {\n      // Validate and include redirect uri\n      parameterBuilder.addRedirectUri(request.redirectUri);\n    }\n    // Add scope array, parameter builder will add default scopes and dedupe\n    parameterBuilder.addScopes(request.scopes, true, this.oidcDefaultScopes);\n    // add code: user set, not validated\n    parameterBuilder.addAuthorizationCode(request.code);\n    // Add library metadata\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    parameterBuilder.addThrottling();\n    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n    }\n    // add code_verifier if passed\n    if (request.codeVerifier) {\n      parameterBuilder.addCodeVerifier(request.codeVerifier);\n    }\n    if (this.config.clientCredentials.clientSecret) {\n      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      const clientAssertion = this.config.clientCredentials.clientAssertion;\n      parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\n      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n    }\n    parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n    parameterBuilder.addClientInfo();\n    if (request.authenticationScheme === AuthenticationScheme.POP) {\n      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n      let reqCnfData;\n      if (!request.popKid) {\n        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n        reqCnfData = generatedReqCnfData.reqCnfString;\n      } else {\n        reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n      }\n      // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n      parameterBuilder.addPopToken(reqCnfData);\n    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n      if (request.sshJwk) {\n        parameterBuilder.addSshJwk(request.sshJwk);\n      } else {\n        throw createClientConfigurationError(missingSshJwk);\n      }\n    }\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    let ccsCred = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCred = {\n          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    } else {\n      ccsCred = request.ccsCredential;\n    }\n    // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n    if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n      switch (ccsCred.type) {\n        case CcsCredentialType.HOME_ACCOUNT_ID:\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n          break;\n        case CcsCredentialType.UPN:\n          parameterBuilder.addCcsUpn(ccsCred.credential);\n          break;\n      }\n    }\n    if (request.embeddedClientId) {\n      parameterBuilder.addBrokerParameters({\n        brokerClientId: this.config.authOptions.clientId,\n        brokerRedirectUri: this.config.authOptions.redirectUri\n      });\n    }\n    if (request.tokenBodyParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n    }\n    // Add hybrid spa parameters if not already provided\n    if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {\n      parameterBuilder.addExtraQueryParameters({\n        [RETURN_SPA_CODE]: \"1\"\n      });\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n  async createAuthCodeUrlQueryString(request) {\n    // generate the correlationId if not set by the user and add\n    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, correlationId);\n    const parameterBuilder = new RequestParameterBuilder(correlationId, this.performanceClient);\n    parameterBuilder.addClientId(request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || this.config.authOptions.clientId);\n    const requestScopes = [...(request.scopes || []), ...(request.extraScopesToConsent || [])];\n    parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);\n    // validate the redirectUri (to be a non null value)\n    parameterBuilder.addRedirectUri(request.redirectUri);\n    parameterBuilder.addCorrelationId(correlationId);\n    // add response_mode. If not passed in it defaults to query.\n    parameterBuilder.addResponseMode(request.responseMode);\n    // add response_type = code\n    parameterBuilder.addResponseTypeCode();\n    // add library info parameters\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    if (!isOidcProtocolMode(this.config)) {\n      parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    }\n    // add client_info=1\n    parameterBuilder.addClientInfo();\n    if (request.codeChallenge && request.codeChallengeMethod) {\n      parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n    }\n    if (request.prompt) {\n      parameterBuilder.addPrompt(request.prompt);\n    }\n    if (request.domainHint) {\n      parameterBuilder.addDomainHint(request.domainHint);\n    }\n    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n      // AAD will throw if prompt=select_account is passed with an account hint\n      if (request.sid && request.prompt === PromptValue.NONE) {\n        // SessionID is only used in silent calls\n        this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n        parameterBuilder.addSid(request.sid);\n      } else if (request.account) {\n        const accountSid = this.extractAccountSid(request.account);\n        let accountLoginHintClaim = this.extractLoginHint(request.account);\n        if (accountLoginHintClaim && request.domainHint) {\n          this.logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: \"domainHint\" param is set, skipping opaque \"login_hint\" claim. Please consider not passing domainHint`);\n          accountLoginHintClaim = null;\n        }\n        // If login_hint claim is present, use it over sid/username\n        if (accountLoginHintClaim) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n          parameterBuilder.addLoginHint(accountLoginHintClaim);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        } else if (accountSid && request.prompt === PromptValue.NONE) {\n          /*\r\n           * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n           * SessionId is only used in silent calls\r\n           */\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n          parameterBuilder.addSid(accountSid);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        } else if (request.loginHint) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n          parameterBuilder.addLoginHint(request.loginHint);\n          parameterBuilder.addCcsUpn(request.loginHint);\n        } else if (request.account.username) {\n          // Fallback to account username if provided\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n          parameterBuilder.addLoginHint(request.account.username);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        }\n      } else if (request.loginHint) {\n        this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n        parameterBuilder.addLoginHint(request.loginHint);\n        parameterBuilder.addCcsUpn(request.loginHint);\n      }\n    } else {\n      this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n    }\n    if (request.nonce) {\n      parameterBuilder.addNonce(request.nonce);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    if (request.embeddedClientId) {\n      parameterBuilder.addBrokerParameters({\n        brokerClientId: this.config.authOptions.clientId,\n        brokerRedirectUri: this.config.authOptions.redirectUri\n      });\n    }\n    this.addExtraQueryParams(request, parameterBuilder);\n    if (request.nativeBroker) {\n      // signal ests that this is a WAM call\n      parameterBuilder.addNativeBroker();\n      // pass the req_cnf for POP\n      if (request.authenticationScheme === AuthenticationScheme.POP) {\n        const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n        // req_cnf is always sent as a string for SPAs\n        let reqCnfData;\n        if (!request.popKid) {\n          const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n          reqCnfData = generatedReqCnfData.reqCnfString;\n        } else {\n          reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n        }\n        parameterBuilder.addPopToken(reqCnfData);\n      }\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n  createLogoutUrlQueryString(request) {\n    const parameterBuilder = new RequestParameterBuilder(request.correlationId, this.performanceClient);\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n    this.addExtraQueryParams(request, parameterBuilder);\n    return parameterBuilder.createQueryString();\n  }\n  addExtraQueryParams(request, parameterBuilder) {\n    const hasRequestInstanceAware = request.extraQueryParameters && request.extraQueryParameters.hasOwnProperty(\"instance_aware\");\n    // Set instance_aware flag if config auth param is set\n    if (!hasRequestInstanceAware && this.config.authOptions.instanceAware) {\n      request.extraQueryParameters = request.extraQueryParameters || {};\n      request.extraQueryParameters[\"instance_aware\"] = \"true\";\n    }\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n  }\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n  extractAccountSid(account) {\n    return account.idTokenClaims?.sid || null;\n  }\n  extractLoginHint(account) {\n    return account.idTokenClaims?.login_hint || null;\n  }\n}\nexport { AuthorizationCodeClient };","map":{"version":3,"names":["AuthorizationCodeClient","BaseClient","constructor","configuration","performanceClient","includeRedirectUri","oidcDefaultScopes","config","authOptions","authority","options","OIDCOptions","defaultScopes","getAuthCodeUrl","request","addQueueMeasurement","PerformanceEvents","GetAuthCodeUrl","correlationId","queryString","invokeAsync","createAuthCodeUrlQueryString","bind","AuthClientCreateQueryString","logger","UrlString","appendQueryString","authorizationEndpoint","acquireToken","authCodePayload","AuthClientAcquireToken","code","createClientAuthError","requestCannotBeMade","reqTimestamp","nowSeconds","response","executeTokenRequest","AuthClientExecuteTokenRequest","requestId","headers","HeaderNames","X_MS_REQUEST_ID","responseHandler","ResponseHandler","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","HandleServerTokenResponse","undefined","handleFragmentResponse","serverParams","cachedState","validateServerAuthorizationCodeResponse","authorizationCodeMissingFromServerResponse","getLogoutUri","logoutRequest","createClientConfigurationError","logoutRequestEmpty","createLogoutUrlQueryString","endSessionEndpoint","queryParametersString","createTokenQueryParameters","endpoint","tokenEndpoint","requestBody","createTokenRequestBody","AuthClientCreateTokenRequestBody","ccsCredential","clientInfo","buildClientInfo","base64Decode","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","verbose","createTokenRequestHeaders","thumbprint","tokenBodyParameters","canonicalAuthority","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","executePostToTokenEndpoint","AuthorizationCodeClientExecutePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","addClientId","embeddedClientId","CLIENT_ID","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","isOidcProtocolMode","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","getClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","reqCnfData","popKid","generatedReqCnfData","generateCnf","PopTokenGenerateCnf","reqCnfString","encodeKid","addPopToken","SSH","sshJwk","addSshJwk","missingSshJwk","StringUtils","isEmptyObj","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","addBrokerParameters","brokerClientId","brokerRedirectUri","addExtraQueryParameters","enableSpaAuthorizationCode","RETURN_SPA_CODE","createQueryString","cryptoInterface","createNewGuid","extraQueryParameters","requestScopes","extraScopesToConsent","addCorrelationId","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","account","accountSid","extractAccountSid","accountLoginHintClaim","extractLoginHint","warning","addLoginHint","homeAccountId","loginHint","username","nonce","addNonce","state","addState","addExtraQueryParams","nativeBroker","addNativeBroker","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","logoutHint","addLogoutHint","hasRequestInstanceAware","hasOwnProperty","instanceAware","idTokenClaims","login_hint"],"sources":["C:\\temp\\NovaApp\\src\\nova.web\\node_modules\\@azure\\msal-common\\src\\client\\AuthorizationCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient.js\";\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest.js\";\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest.js\";\nimport { Authority } from \"../authority/Authority.js\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder.js\";\nimport {\n    GrantType,\n    AuthenticationScheme,\n    PromptValue,\n    Separators,\n    HeaderNames,\n} from \"../utils/Constants.js\";\nimport * as AADServerParamKeys from \"../constants/AADServerParamKeys.js\";\nimport {\n    ClientConfiguration,\n    isOidcProtocolMode,\n} from \"../config/ClientConfiguration.js\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse.js\";\nimport { NetworkResponse } from \"../network/NetworkResponse.js\";\nimport { ResponseHandler } from \"../response/ResponseHandler.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { StringUtils } from \"../utils/StringUtils.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport { UrlString } from \"../url/UrlString.js\";\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse.js\";\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest.js\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator.js\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint.js\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload.js\";\nimport * as TimeUtils from \"../utils/TimeUtils.js\";\nimport { AccountInfo } from \"../account/AccountInfo.js\";\nimport {\n    buildClientInfoFromHomeAccountId,\n    buildClientInfo,\n} from \"../account/ClientInfo.js\";\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential.js\";\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError.js\";\nimport { RequestValidator } from \"../request/RequestValidator.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { ClientAssertion } from \"../account/ClientCredentials.js\";\nimport { getClientAssertion } from \"../utils/ClientAssertionUtils.js\";\n\n/**\n * Oauth2.0 Authorization Code client\n * @internal\n */\nexport class AuthorizationCodeClient extends BaseClient {\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    protected includeRedirectUri: boolean = true;\n    private oidcDefaultScopes;\n\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n        this.oidcDefaultScopes =\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n    }\n\n    /**\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\n     * application. The URL target the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * acquireToken(AuthorizationCodeRequest)\n     * @param request\n     */\n    async getAuthCodeUrl(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.GetAuthCodeUrl,\n            request.correlationId\n        );\n\n        const queryString = await invokeAsync(\n            this.createAuthCodeUrlQueryString.bind(this),\n            PerformanceEvents.AuthClientCreateQueryString,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        return UrlString.appendQueryString(\n            this.authority.authorizationEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n     * authorization_code_grant\n     * @param request\n     */\n    async acquireToken(\n        request: CommonAuthorizationCodeRequest,\n        authCodePayload?: AuthorizationCodePayload\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientAcquireToken,\n            request.correlationId\n        );\n\n        if (!request.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.requestCannotBeMade\n            );\n        }\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await invokeAsync(\n            this.executeTokenRequest.bind(this),\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authority, request);\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin,\n            this.performanceClient\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n\n        return invokeAsync(\n            responseHandler.handleServerTokenResponse.bind(responseHandler),\n            PerformanceEvents.HandleServerTokenResponse,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            authCodePayload,\n            undefined,\n            undefined,\n            undefined,\n            requestId\n        );\n    }\n\n    /**\n     * Handles the hash fragment response from public client code request. Returns a code response used by\n     * the client to exchange for a token in acquireToken.\n     * @param hashFragment\n     */\n    handleFragmentResponse(\n        serverParams: ServerAuthorizationCodeResponse,\n        cachedState: string\n    ): AuthorizationCodePayload {\n        // Handle responses.\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            null,\n            null\n        );\n\n        // Get code response\n        responseHandler.validateServerAuthorizationCodeResponse(\n            serverParams,\n            cachedState\n        );\n\n        // throw when there is no auth code in the response\n        if (!serverParams.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.authorizationCodeMissingFromServerResponse\n            );\n        }\n\n        return serverParams as AuthorizationCodePayload;\n    }\n\n    /**\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param authorityUri\n     */\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\n        // Throw error if logoutRequest is null/undefined\n        if (!logoutRequest) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.logoutRequestEmpty\n            );\n        }\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\n\n        // Construct logout URI\n        return UrlString.appendQueryString(\n            this.authority.endSessionEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority\n     * @param request\n     */\n    private async executeTokenRequest(\n        authority: Authority,\n        request: CommonAuthorizationCodeRequest\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            request.correlationId\n        );\n\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n\n        const requestBody = await invokeAsync(\n            this.createTokenRequestBody.bind(this),\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        let ccsCredential: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCredential = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        }\n        const headers: Record<string, string> = this.createTokenRequestHeaders(\n            ccsCredential || request.ccsCredential\n        );\n\n        const thumbprint: RequestThumbprint = {\n            clientId:\n                request.tokenBodyParameters?.clientId ||\n                this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        return invokeAsync(\n            this.executePostToTokenEndpoint.bind(this),\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId,\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint\n        );\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request\n     */\n    private async createTokenRequestBody(\n        request: CommonAuthorizationCodeRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const parameterBuilder = new RequestParameterBuilder(\n            request.correlationId,\n            this.performanceClient\n        );\n\n        parameterBuilder.addClientId(\n            request.embeddedClientId ||\n                request.tokenBodyParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        /*\n         * For hybrid spa flow, there will be a code but no verifier\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n         */\n        if (!this.includeRedirectUri) {\n            // Just validate\n            RequestValidator.validateRedirectUri(request.redirectUri);\n        } else {\n            // Validate and include redirect uri\n            parameterBuilder.addRedirectUri(request.redirectUri);\n        }\n\n        // Add scope array, parameter builder will add default scopes and dedupe\n        parameterBuilder.addScopes(\n            request.scopes,\n            true,\n            this.oidcDefaultScopes\n        );\n\n        // add code: user set, not validated\n        parameterBuilder.addAuthorizationCode(request.code);\n\n        // Add library metadata\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        parameterBuilder.addApplicationTelemetry(\n            this.config.telemetry.application\n        );\n        parameterBuilder.addThrottling();\n\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        // add code_verifier if passed\n        if (request.codeVerifier) {\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\n        }\n\n        if (this.config.clientCredentials.clientSecret) {\n            parameterBuilder.addClientSecret(\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion: ClientAssertion =\n                this.config.clientCredentials.clientAssertion;\n\n            parameterBuilder.addClientAssertion(\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            parameterBuilder.addClientAssertionType(\n                clientAssertion.assertionType\n            );\n        }\n\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n        parameterBuilder.addClientInfo();\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(\n                this.cryptoUtils,\n                this.performanceClient\n            );\n\n            let reqCnfData;\n            if (!request.popKid) {\n                const generatedReqCnfData = await invokeAsync(\n                    popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                    PerformanceEvents.PopTokenGenerateCnf,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(request, this.logger);\n                reqCnfData = generatedReqCnfData.reqCnfString;\n            } else {\n                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n            }\n\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            parameterBuilder.addPopToken(reqCnfData);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n            } else {\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.missingSshJwk\n                );\n            }\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        let ccsCred: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCred = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        } else {\n            ccsCred = request.ccsCredential;\n        }\n\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n            switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            ccsCred.credential\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"Could not parse home account ID for CCS Header: \" +\n                                e\n                        );\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\n                    break;\n            }\n        }\n\n        if (request.embeddedClientId) {\n            parameterBuilder.addBrokerParameters({\n                brokerClientId: this.config.authOptions.clientId,\n                brokerRedirectUri: this.config.authOptions.redirectUri,\n            });\n        }\n\n        if (request.tokenBodyParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.tokenBodyParameters\n            );\n        }\n\n        // Add hybrid spa parameters if not already provided\n        if (\n            request.enableSpaAuthorizationCode &&\n            (!request.tokenBodyParameters ||\n                !request.tokenBodyParameters[\n                    AADServerParamKeys.RETURN_SPA_CODE\n                ])\n        ) {\n            parameterBuilder.addExtraQueryParameters({\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\",\n            });\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n     * @param request\n     */\n    private async createAuthCodeUrlQueryString(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<string> {\n        // generate the correlationId if not set by the user and add\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateQueryString,\n            correlationId\n        );\n\n        const parameterBuilder = new RequestParameterBuilder(\n            correlationId,\n            this.performanceClient\n        );\n\n        parameterBuilder.addClientId(\n            request.embeddedClientId ||\n                request.extraQueryParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        const requestScopes = [\n            ...(request.scopes || []),\n            ...(request.extraScopesToConsent || []),\n        ];\n        parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);\n\n        // validate the redirectUri (to be a non null value)\n        parameterBuilder.addRedirectUri(request.redirectUri);\n\n        parameterBuilder.addCorrelationId(correlationId);\n\n        // add response_mode. If not passed in it defaults to query.\n        parameterBuilder.addResponseMode(request.responseMode);\n\n        // add response_type = code\n        parameterBuilder.addResponseTypeCode();\n\n        // add library info parameters\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        if (!isOidcProtocolMode(this.config)) {\n            parameterBuilder.addApplicationTelemetry(\n                this.config.telemetry.application\n            );\n        }\n\n        // add client_info=1\n        parameterBuilder.addClientInfo();\n\n        if (request.codeChallenge && request.codeChallengeMethod) {\n            parameterBuilder.addCodeChallengeParams(\n                request.codeChallenge,\n                request.codeChallengeMethod\n            );\n        }\n\n        if (request.prompt) {\n            parameterBuilder.addPrompt(request.prompt);\n        }\n\n        if (request.domainHint) {\n            parameterBuilder.addDomainHint(request.domainHint);\n        }\n\n        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n            // AAD will throw if prompt=select_account is passed with an account hint\n            if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\n                    \"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\"\n                );\n                parameterBuilder.addSid(request.sid);\n            } else if (request.account) {\n                const accountSid = this.extractAccountSid(request.account);\n                let accountLoginHintClaim = this.extractLoginHint(\n                    request.account\n                );\n\n                if (accountLoginHintClaim && request.domainHint) {\n                    this.logger.warning(\n                        `AuthorizationCodeClient.createAuthCodeUrlQueryString: \"domainHint\" param is set, skipping opaque \"login_hint\" claim. Please consider not passing domainHint`\n                    );\n                    accountLoginHintClaim = null;\n                }\n\n                // If login_hint claim is present, use it over sid/username\n                if (accountLoginHintClaim) {\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: login_hint claim present on account\"\n                    );\n                    parameterBuilder.addLoginHint(accountLoginHintClaim);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                    /*\n                     * If account and loginHint are provided, we will check account first for sid before adding loginHint\n                     * SessionId is only used in silent calls\n                     */\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\"\n                    );\n                    parameterBuilder.addSid(accountSid);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                } else if (request.loginHint) {\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Adding login_hint from request\"\n                    );\n                    parameterBuilder.addLoginHint(request.loginHint);\n                    parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                    // Fallback to account username if provided\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Adding login_hint from account\"\n                    );\n                    parameterBuilder.addLoginHint(request.account.username);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                }\n            } else if (request.loginHint) {\n                this.logger.verbose(\n                    \"createAuthCodeUrlQueryString: No account, adding login_hint from request\"\n                );\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n            }\n        } else {\n            this.logger.verbose(\n                \"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\"\n            );\n        }\n\n        if (request.nonce) {\n            parameterBuilder.addNonce(request.nonce);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (\n            request.claims ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        if (request.embeddedClientId) {\n            parameterBuilder.addBrokerParameters({\n                brokerClientId: this.config.authOptions.clientId,\n                brokerRedirectUri: this.config.authOptions.redirectUri,\n            });\n        }\n\n        this.addExtraQueryParams(request, parameterBuilder);\n\n        if (request.nativeBroker) {\n            // signal ests that this is a WAM call\n            parameterBuilder.addNativeBroker();\n\n            // pass the req_cnf for POP\n            if (request.authenticationScheme === AuthenticationScheme.POP) {\n                const popTokenGenerator = new PopTokenGenerator(\n                    this.cryptoUtils\n                );\n\n                // req_cnf is always sent as a string for SPAs\n                let reqCnfData;\n                if (!request.popKid) {\n                    const generatedReqCnfData = await invokeAsync(\n                        popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                        PerformanceEvents.PopTokenGenerateCnf,\n                        this.logger,\n                        this.performanceClient,\n                        request.correlationId\n                    )(request, this.logger);\n                    reqCnfData = generatedReqCnfData.reqCnfString;\n                } else {\n                    reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n                }\n                parameterBuilder.addPopToken(reqCnfData);\n            }\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `EndSessionRequest` and creates a URL\n     * @param request\n     */\n    private createLogoutUrlQueryString(\n        request: CommonEndSessionRequest\n    ): string {\n        const parameterBuilder = new RequestParameterBuilder(\n            request.correlationId,\n            this.performanceClient\n        );\n\n        if (request.postLogoutRedirectUri) {\n            parameterBuilder.addPostLogoutRedirectUri(\n                request.postLogoutRedirectUri\n            );\n        }\n\n        if (request.correlationId) {\n            parameterBuilder.addCorrelationId(request.correlationId);\n        }\n\n        if (request.idTokenHint) {\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (request.logoutHint) {\n            parameterBuilder.addLogoutHint(request.logoutHint);\n        }\n\n        this.addExtraQueryParams(request, parameterBuilder);\n\n        return parameterBuilder.createQueryString();\n    }\n\n    private addExtraQueryParams(\n        request: CommonAuthorizationUrlRequest | CommonEndSessionRequest,\n        parameterBuilder: RequestParameterBuilder\n    ) {\n        const hasRequestInstanceAware =\n            request.extraQueryParameters &&\n            request.extraQueryParameters.hasOwnProperty(\"instance_aware\");\n\n        // Set instance_aware flag if config auth param is set\n        if (!hasRequestInstanceAware && this.config.authOptions.instanceAware) {\n            request.extraQueryParameters = request.extraQueryParameters || {};\n            request.extraQueryParameters[\"instance_aware\"] = \"true\";\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.extraQueryParameters\n            );\n        }\n    }\n\n    /**\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n     * @param account\n     */\n    private extractAccountSid(account: AccountInfo): string | null {\n        return account.idTokenClaims?.sid || null;\n    }\n\n    private extractLoginHint(account: AccountInfo): string | null {\n        return account.idTokenClaims?.login_hint || null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}